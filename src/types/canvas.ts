/**
 * @file canvas.ts
 * @description TypeScript типы для NeuroCanvas - бесконечного холста с AI-нодами
 */

import type { Node, Edge } from '@xyflow/react';

// =============================================================================
// РЕЖИМЫ РАБОТЫ НОДЫ
// =============================================================================

/**
 * Режим отображения ноды:
 * - 'input' - компактный режим ввода (search bar)
 * - 'result' - расширенный режим с результатом AI
 */
export type NodeMode = 'input' | 'result';

// =============================================================================
// ВЛОЖЕНИЯ (ATTACHMENTS)
// =============================================================================
//
// ВАЖНО:
// - Вложения нужны для мультимодальных моделей (картинки) и текстовых “доков” (контекст).
// - Мы ХРАНИМ в ноде ТОЛЬКО метаданные и `attachmentId`, а сами файлы лежат на диске:
//   data/attachments/<canvasId>/<attachmentId>
// - Это сделано намеренно:
//   1) canvas.json не раздувается base64-данными
//   2) вложения легко кешировать/отдавать как файлы
//   3) сохраняется путь для будущего чанкинга больших файлов
//
// Безопасность:
// - `attachmentId` генерируется на сервере (UUID + расширение).
// - Клиент НЕ управляет путём к файлу, чтобы исключить path traversal.

/**
 * Тип вложения на уровне смысла (что это за данные).
 */
export type AttachmentKind = 'image' | 'text';

/**
 * Режим “поглощения” вложения в контекст LLM.
 *
 * Сейчас (MVP):
 * - `inline`:
 *   - text: читаем целиком и вставляем в system-context
 *   - image: отправляем как multimodal content (image_url)
 *
 * Будущее (V2/V3):
 * - `chunked`:
 *   - файл разбивается на чанки, индексируется, и в контекст подмешиваются
 *     только релевантные части (RAG по вложениям).
 */
export type AttachmentIngestionMode = 'inline' | 'chunked';

/**
 * Метаданные вложения, которые хранятся в `node.data`.
 *
 * ВАЖНО:
 * - Здесь НЕТ `canvasId` намеренно.
 *   `canvasId` — это “контекст хранилища”, он есть в workspace/store.
 *   Так дубликат холста может копировать папку вложений целиком без переписывания
 *   каждой ноды, а метаданные остаются валидными.
 */
export interface NodeAttachment {
  /**
   * Уникальный идентификатор файла вложения в рамках холста.
   *
   * Формат: UUIDv4 + расширение (например: `2f6c2e1a-....-a9.png`).
   *
   * Почему именно так:
   * - UUID устраняет коллизии (одинаковые имена файлов у пользователя)
   * - “+ расширение” удобно для:
   *   - корректного Content-Type fallback при выдаче
   *   - отладки в файловой системе
   * - НИКОГДА не используем оригинальное имя как путь/ID (path traversal риск)
   */
  attachmentId: string;

  /** Тип вложения (картинка или текст). */
  kind: AttachmentKind;

  /**
   * Исходное имя файла (то, что показано пользователю).
   *
   * ВАЖНО:
   * - Это поле НЕ используется для построения путей!
   * - Только для отображения и “человеческих” заголовков в контексте.
   */
  originalName: string;

  /**
   * MIME тип (как определил СЕРВЕР).
   *
   * Почему сервер:
   * - клиент может подменить `file.type` и расширение
   * - сервер проверяет “реальный” тип по magic bytes (для изображений)
   */
  mime: string;

  /** Размер файла в байтах (для лимитов и UX). */
  sizeBytes: number;

  // =============================================================================
  // "ВЕРСИЯ" ФАЙЛА (ДЛЯ ГЛОБАЛЬНЫХ ВЛОЖЕНИЙ НА ХОЛСТ)
  // =============================================================================
  //
  // Важно:
  // - В будущем у каждого холста будет файловый менеджер, а карточки будут хранить ссылки.
  // - Уже сейчас мы реализуем upsert по имени файла (в пределах холста):
  //   загрузка файла с тем же именем обновляет существующий файл на диске,
  //   но attachmentId остаётся прежним.
  //
  // Проблема:
  // - Если attachmentId не меняется, то "контекст" у карточек-ссылок меняется,
  //   но это не заметно по одному attachmentId.
  //
  // Решение:
  // - Добавляем "версию файла":
  //   - fileHash: хэш содержимого
  //   - fileUpdatedAt: когда именно файл обновлялся
  //
  // Эти поля используются для:
  // - вычисления context-hash (stale/актуальность),
  // - диагностики,
  // - будущей синхронизации файлового менеджера.

  /** SHA-256 хэш содержимого файла (версия). Может отсутствовать у старых холстов. */
  fileHash?: string;

  /** Время последнего обновления содержимого файла (epoch ms). Может отсутствовать у старых холстов. */
  fileUpdatedAt?: number;

  /**
   * Когда вложение было добавлено.
   *
   * Зачем нужно:
   * - сортировка
   * - отладка
   * - (в будущем) эвристики на релевантность “по свежести”
   */
  createdAt: number;

  /** Режим включения в контекст (с заделом на chunking). */
  ingestionMode: AttachmentIngestionMode;
}

// =============================================================================
// ДАННЫЕ НОДЫ
// =============================================================================

/**
 * Данные, хранящиеся внутри каждой NeuroNode
 */
export interface NeuroNodeData {
  /** Текст промпта, введённый пользователем */
  prompt: string;

  // =============================================================================
  // ВЛОЖЕНИЯ (ATTACHMENTS)
  // =============================================================================
  //
  // ВАЖНО:
  // - Вложения принадлежат текущей ноде (карточке), а не всему холсту.
  // - Мы подмешиваем их в LLM запрос при генерации ответа этой ноды.
  // - Изменение вложений считается изменением контекста → такие ноды должны становиться stale,
  //   если у них уже есть response (это будет реализовано на уровне UI/store).

  /**
   * Список вложений, прикреплённых к карточке.
   *
   * `undefined` означает “вложений нет” и экономит место в JSON.
   * В UI можно считать `undefined` и `[]` эквивалентными.
   */
  attachments?: NodeAttachment[];

  /** Ответ от AI (null если ещё не сгенерирован) */
  response: string | null;

  /**
   * Краткая суть ответа (2-3 предложения)
   * Используется для передачи контекста внукам, правнукам и т.д.
   * Не отображается в UI, только для внутреннего использования
   */
  summary: string | null;

  /** Флаг: идёт ли сейчас генерация основного ответа */
  isGenerating: boolean;

  /** Флаг: идёт ли сейчас генерация summary */
  isSummarizing: boolean;

  /** Флаг: устарели ли данные (родитель был изменён или удалён) */
  isStale: boolean;

  /** Флаг: раскрыта ли ответная часть карточки (слайдер) */
  isAnswerExpanded: boolean;

  // =============================================================================
  // ПОЛЯ ДЛЯ ЦИТИРОВАНИЯ
  // =============================================================================

  /**
   * Текст цитаты из родительской ноды
   * null если это не цитатная карточка (обычная дочерняя карточка)
   */
  quote: string | null;

  /**
   * ID ноды-источника цитаты
   * Указывает на ноду, из ответа которой была взята цитата
   */
  quoteSourceNodeId: string | null;

  /**
   * Исходный response ноды-источника на момент создания цитаты
   * Используется для сравнения и определения изменений
   * Если response изменился - цитата становится неактуальной
   */
  quoteOriginalResponse: string | null;

  /**
   * Флаг: цитата стала неактуальной
   * true если исходный текст response изменился после создания цитаты
   * Такие карточки подсвечиваются красным и требуют повторного выделения цитаты
   */
  isQuoteInvalidated: boolean;

  /**
   * Флаг: активен ли режим цитирования в этой карточке
   * Используется для активации режима цитирования из дочерней карточки
   * когда пользователь нажимает "Выделить новую цитату"
   */
  isQuoteModeActive?: boolean;

  /**
   * ID дочерней карточки, которая инициировала режим цитирования
   * Когда пользователь выделит новую цитату, она будет обновлена в этой карточке
   * null если режим цитирования был инициирован локально (для создания новой карточки)
   */
  quoteModeInitiatedByNodeId?: string | null;

  /**
   * Флаг: требуется ли перегенерация ответа
   * Устанавливается в true после обновления цитаты в дочерней карточке
   * Компонент NeuroNode автоматически запускает генерацию при этом флаге
   */
  pendingRegenerate?: boolean;

  /**
   * Хэш контекста на момент последней генерации ответа
   * 
   * Используется для автоматического снятия статуса stale:
   * - После генерации ответа сохраняется хэш всего контекста (промпт + цитата + response родителей + summary предков)
   * - При изменениях (связей, цитат и т.д.) проверяется: если текущий контекст совпадает с сохранённым хэшем - stale снимается
   * - Это позволяет "откатить" изменения без потери актуальности карточки
   */
  lastContextHash: string | null;

  /**
   * Список ID нод, которые пользователь вручную исключил из контекста
   * Эти ноды НЕ будут участвовать в формировании контекста для LLM
   */
  excludedContextNodeIds?: string[];

  // =============================================================================
  // ВЛОЖЕНИЯ КАК КОНТЕКСТ (ATTACHMENTS AS ANCESTRY)
  // =============================================================================
  //
  // Задача:
  // - Вложения должны "вести себя как предки":
  //   - у прямого потомка (1 hop) — полный текст документа (inline через /api/chat)
  //   - у более дальних потомков (2+ hops) — суммаризация/суть документа
  //
  // Как реализуем в MVP:
  // - Сами файлы остаются на диске (data/attachments/...).
  // - В node.data мы храним:
  //   1) excludedAttachmentIds — какие файлы ИСКЛЮЧИТЬ из контекста этой ноды
  //   2) attachmentExcerpts   — короткие "выжимки" (fallback) по attachmentId
  //   3) attachmentSummaries  — LLM-суммаризации по attachmentId (если доступны)
  //
  // Почему не храним полный текст в JSON:
  // - иначе canvas.json раздуется и станет медленным/хрупким.
  // - полный текст для прямого потомка подмешивается сервером "по ID файла".

  /**
   * Какие attachmentId пользователь выключил из контекста ДАННОЙ карточки.
   *
   * Важно:
   * - Это отличается от "удалить вложение" (удаление физически убирает файл).
   * - Здесь мы оставляем файл прикреплённым, но НЕ используем его при генерации
   *   ответа и не показываем как "активный контекст" в ContextViewerModal.
   */
  excludedAttachmentIds?: string[];

  /**
   * Короткие выдержки (fallback) по текстовым вложениям.
   *
   * Используются:
   * - для отображения в ContextViewerModal без необходимости сразу грузить файл,
   * - как fallback-контекст для дальних потомков, если суммаризация недоступна.
   */
  attachmentExcerpts?: Record<string, string>;

  /**
   * Суммаризации текстовых вложений (LLM-generated).
   *
   * Используются:
   * - для передачи "смысла документа" дальним потомкам (2+ поколений),
   *   чтобы не тащить полный текст и не тратить контекстное окно модели.
   */
  attachmentSummaries?: Record<string, string>;

  /**
   * Подробное описание изображений (caption-only, 5–10 предложений) по attachmentId.
   *
   * Зачем нужно:
   * - изображения тоже должны "вести себя как предки":
   *   - у владельца могут участвовать как multimodal (image_url) в запросе
   *   - у детей/предков мы передаём только описание (caption)
   *
   * Важно:
   * - мы НЕ храним base64 картинки в JSON
   * - мы НЕ храним отдельный OCR-слой как отдельные данные
   * - мы НЕ цитируем текст с изображения дословно (особенно код/логи)
   * - если на изображении есть текст, мы сохраняем только СМЫСЛ/объяснение в описании
   */
  attachmentImageDescriptions?: Record<string, string>;

  /** Текущий режим отображения ноды */
  mode: NodeMode;

  /** ID родительской ноды (для отслеживания зависимостей) */
  parentId?: string;

  /**
   * Массив ID родительских нод (для карточек с несколькими родителями)
   * Используется когда карточка создаётся от нескольких выделенных карточек через Tab
   * Если указан - имеет приоритет над parentId при построении контекста
   */
  parentIds?: string[];

  // =============================================================================
  // ПОЛЯ ДЛЯ НЕЙРОПОИСКА (ВИРТУАЛЬНЫЕ СВЯЗИ)
  // =============================================================================

  /**
   * Массив ID карточек, подключённых через NeuroSearch (виртуальные родители)
   * 
   * Эти карточки добавляются в контекст при генерации ответа LLM,
   * как если бы они были реальными родительскими связями.
   * 
   * При передаче контекста потомкам - они передаются как суммаризация
   * (аналогично дедушкам/бабушкам в обычной иерархии).
   * 
   * Обновляется при выполнении NeuroSearch.
   * null/undefined если нейропоиск не использовался.
   */
  neuroSearchNodeIds?: string[];

  /** Ширина карточки (для resize) */
  width?: number;

  /** Временная метка создания */
  createdAt: number;

  /** Временная метка последнего обновления */
  updatedAt: number;

  /**
   * Index signature для совместимости с React Flow
   * React Flow требует чтобы data имел тип Record<string, unknown>
   */
  [key: string]: unknown;
}

// =============================================================================
// ТИПЫ REACT FLOW
// =============================================================================

/**
 * Кастомный тип ноды для React Flow
 * Расширяет базовый Node тип данными NeuroNodeData
 */
export type NeuroNode = Node<NeuroNodeData, 'neuro' | 'note'>;

// =============================================================================
// ДАННЫЕ СВЯЗИ (EDGE)
// =============================================================================

/**
 * Кастомные данные для связей между нодами
 * 
 * Используются для хранения метаинформации о связи,
 * например, является ли связь цитатной.
 */
export interface NeuroEdgeData {
  /**
   * Флаг: является ли эта связь цитатной
   * 
   * true - связь создана при цитировании текста из родительской карточки
   * Такие связи отображаются пурпурным цветом для визуального
   * выделения источника цитаты среди других родителей.
   */
  isQuoteEdge?: boolean;

  /**
   * Index signature для совместимости с React Flow
   * React Flow требует чтобы data имел тип Record<string, unknown>
   */
  [key: string]: unknown;
}

/**
 * Тип связи между нодами
 * 
 * Расширяет стандартный Edge из React Flow кастомными данными.
 * Поле data содержит NeuroEdgeData для хранения метаинформации.
 */
export type NeuroEdge = Edge<NeuroEdgeData>;

// =============================================================================
// СОСТОЯНИЕ CANVAS STORE
// =============================================================================

/**
 * Состояние Zustand store для управления холстом
 */
export interface CanvasState {
  /** Массив всех нод на холсте */
  nodes: NeuroNode[];

  /** Массив всех связей между нодами */
  edges: NeuroEdge[];

  /** ID текущей выбранной ноды (для операций) */
  selectedNodeId: string | null;

  /**
   * ID ноды, которая ожидает фокус на textarea
   * Используется для автофокуса при создании новой карточки через Tab
   * После фокусировки сбрасывается в null
   */
  pendingFocusNodeId: string | null;

  /**
   * ID ноды, на которую нужно центрировать холст
   * Используется после создания новой карточки
   * После центрирования сбрасывается в null
   */
  pendingCenterNodeId: string | null;

  // ===========================================================================
  // СОСТОЯНИЕ ПАКЕТНОЙ РЕГЕНЕРАЦИИ
  // ===========================================================================

  /**
   * Флаг: идёт ли пакетная регенерация устаревших карточек
   */
  isBatchRegenerating: boolean;

  /**
   * Прогресс пакетной регенерации
   */
  batchRegenerationProgress: {
    /** Общее количество карточек для регенерации */
    total: number;
    /** Количество завершённых карточек */
    completed: number;
    /** Текущий уровень в иерархии (0 = корни) */
    currentLevel: number;
    /** ID карточек на текущем уровне (ожидают завершения) */
    currentLevelNodeIds: string[];
  } | null;

  /**
   * Флаг для отмены пакетной регенерации
   * Проверяется перед переходом к следующему уровню
   */
  batchRegenerationCancelled: boolean;
}

// =============================================================================
// ACTIONS (ЭКШЕНЫ) ДЛЯ STORE
// =============================================================================

/**
 * Экшены для управления состоянием холста
 */
export interface CanvasActions {
  /**
   * Добавить новую ноду на холст
   * @param position - координаты размещения {x, y}
   * @param parentId - опциональный ID родительской ноды для создания связи
   * @returns ID созданной ноды
   */
  addNode: (position: { x: number; y: number }, parentId?: string) => string;
  addNoteNode: (position: { x: number; y: number }) => string;

  /**
   * Обновить данные существующей ноды
   * @param nodeId - ID ноды для обновления
   * @param data - частичные данные для обновления
   */
  updateNodeData: (nodeId: string, data: Partial<NeuroNodeData>) => void;

  /**
   * Установить флаг "устаревшей" ноды
   * @param nodeId - ID ноды
   * @param isStale - новое значение флага
   */
  setNodeStale: (nodeId: string, isStale: boolean) => void;

  /**
   * Пометить всех потомков ноды как устаревшие
   * Используется при редактировании промпта родителя
   * @param nodeId - ID родительской ноды
   */
  markChildrenStale: (nodeId: string) => void;

  /**
   * Удалить ноду с холста
   * @param nodeId - ID ноды для удаления
   */
  removeNode: (nodeId: string) => void;

  /**
   * Установить выбранную ноду
   * @param nodeId - ID ноды или null для сброса выбора
   */
  setSelectedNode: (nodeId: string | null) => void;

  /**
   * Callback для React Flow: обработка изменений нод
   * (перемещение, выделение и т.д.)
   */
  onNodesChange: (changes: import('@xyflow/react').NodeChange<NeuroNode>[]) => void;

  /**
   * Callback для React Flow: обработка изменений связей
   * (создание, удаление связей)
   */
  onEdgesChange: (changes: import('@xyflow/react').EdgeChange<NeuroEdge>[]) => void;

  /**
   * Callback для React Flow: обработка создания новой связи
   * (соединение двух нод)
   */
  onConnect: (connection: import('@xyflow/react').Connection) => void;

  /**
   * Создать связанную ноду справа от указанной
   * Используется для быстрого создания карточки по Tab
   * 
   * @param nodeId - ID исходной ноды
   * @returns ID созданной ноды
   */
  createLinkedNodeRight: (nodeId: string) => string | null;

  /**
   * Создать ноду от нескольких родителей
   * 
   * Используется когда выделено несколько карточек рамкой и нажат Tab.
   * Новая карточка:
   * - Связана (edge) со ВСЕМИ выделенными карточками
   * - Располагается справа от самой правой карточки
   * - Центрируется по высоте между крайними выделенными карточками
   * - Автоматически получает фокус
   * 
   * @param nodeIds - массив ID родительских нод
   * @returns ID созданной ноды или null если родители не найдены
   */
  createNodeFromMultipleParents: (nodeIds: string[]) => string | null;

  /**
   * Установить ID ноды для отложенного фокуса
   * @param nodeId - ID ноды или null для сброса
   */
  setPendingFocusNodeId: (nodeId: string | null) => void;

  /**
   * Сбросить pendingFocusNodeId (вызывается после успешного фокуса)
   */
  clearPendingFocus: () => void;

  /**
   * Создать "сестринскую" ноду (от того же родителя)
   * Используется для альтернативных веток размышления (Ctrl+Enter)
   * 
   * @param nodeId - ID текущей ноды (сестра будет создана от её родителя)
   * @returns ID созданной ноды или null
   */
  createSiblingNode: (nodeId: string) => string | null;

  /**
   * Установить ID ноды для центрирования холста
   * @param nodeId - ID ноды или null для сброса
   */
  setPendingCenterNodeId: (nodeId: string | null) => void;

  /**
   * Сбросить pendingCenterNodeId (вызывается после центрирования)
   */
  clearPendingCenter: () => void;

  /**
   * Переключить раскрытие/сворачивание ответной части карточки
   * @param nodeId - ID ноды для переключения
   */
  toggleNodeAnswerExpanded: (nodeId: string) => void;

  /**
   * Переключить раскрытие/сворачивание ответной части для ВСЕХ выделенных карточек
   */
  toggleSelectedNodesAnswerExpanded: () => void;

  /**
   * Снять выделение со всех карточек
   * Используется при открытии режима чтения
   */
  clearSelection: () => void;

  // =============================================================================
  // ЭКШЕНЫ ДЛЯ ЦИТИРОВАНИЯ
  // =============================================================================

  /**
   * Создать карточку на основе цитаты из ответа
   * 
   * Новая карточка:
   * - Размещается справа от ноды-источника
   * - Содержит цитату в поле quote
   * - Сохраняет оригинальный response для отслеживания изменений
   * - Автоматически получает фокус
   * 
   * @param sourceNodeId - ID ноды, из ответа которой взята цитата
   * @param quoteText - выделенный текст цитаты
   * @returns ID созданной ноды или null если исходная нода не найдена
   */
  createQuoteNode: (sourceNodeId: string, quoteText: string) => string | null;

  /**
   * Сбросить инвалидацию цитаты
   * 
   * Очищает флаг isQuoteInvalidated и все quote* поля,
   * позволяя пользователю выделить новую цитату
   * 
   * @param nodeId - ID ноды для сброса
   */
  clearQuoteInvalidation: (nodeId: string) => void;

  /**
   * Обновить цитату в существующей карточке
   * 
   * Используется когда пользователь выделяет новую цитату
   * после инвалидации предыдущей
   * 
   * @param nodeId - ID ноды для обновления цитаты
   * @param quoteText - новый текст цитаты
   * @param sourceNodeId - ID ноды-источника цитаты
   * @param originalResponse - текущий response источника
   */
  updateQuote: (
    nodeId: string,
    quoteText: string,
    sourceNodeId: string,
    originalResponse: string
  ) => void;

  /**
   * Инициировать режим выбора цитаты в родительской карточке
   * 
   * Вызывается из дочерней карточки с инвалидированной цитатой.
   * Активирует родительскую карточку, разворачивает её и включает режим цитирования.
   * 
   * @param quoteNodeId - ID дочерней карточки с инвалидированной цитатой
   */
  initiateQuoteSelectionInParent: (quoteNodeId: string) => void;

  /**
   * Сбросить режим цитирования в ноде
   * 
   * Очищает флаги isQuoteModeActive и quoteModeInitiatedByNodeId
   * 
   * @param nodeId - ID ноды для сброса
   */
  clearQuoteModeActive: (nodeId: string) => void;

  // =============================================================================
  // ЭКШЕНЫ ДЛЯ АВТОМАТИЧЕСКОГО СНЯТИЯ STALE (CONTEXT HASH)
  // =============================================================================

  /**
   * Вычислить и сохранить хэш контекста для ноды
   * 
   * Вызывается ПОСЛЕ успешной генерации ответа.
   * Сохраняет "эталонный" хэш контекста.
   * 
   * @param nodeId - ID ноды для которой сохранить хэш
   */
  saveContextHash: (nodeId: string) => void;

  /**
   * Получить текущий хэш контекста для ноды (без сохранения)
   * 
   * @param nodeId - ID ноды
   * @returns хэш-строка или null
   */
  getContextHash: (nodeId: string) => string | null;

  /**
   * Проверить и снять stale если контекст вернулся к эталонному
   * 
   * Рекурсивно проверяет ноду и всех её потомков
   * 
   * @param nodeId - ID ноды для начала проверки
   */
  checkAndClearStale: (nodeId: string) => void;

  /**
   * Проверить и снять stale для ВСЕХ stale нод на холсте
   * 
   * Используется после массовых изменений
   */
  checkAllStaleNodes: () => void;

  // =============================================================================
  // ЭКШЕНЫ ДЛЯ ПАКЕТНОЙ РЕГЕНЕРАЦИИ УСТАРЕВШИХ КАРТОЧЕК
  // =============================================================================

  /**
   * Получить количество устаревших (stale) карточек
   * 
   * @returns количество карточек с isStale === true
   */
  getStaleNodesCount: () => number;

  /**
   * Запустить пакетную регенерацию всех устаревших карточек
   * 
   * Алгоритм:
   * 1. Собрать все stale ноды
   * 2. Построить граф зависимостей (от предков к потомкам)
   * 3. Топологическая сортировка по уровням
   * 4. На каждом уровне запускать параллельно (сиблинги независимы)
   * 5. Дождаться завершения уровня перед переходом к следующему
   */
  regenerateStaleNodes: () => void;

  /**
   * Отменить текущую пакетную регенерацию
   */
  cancelBatchRegeneration: () => void;

  /**
   * Обработать завершение генерации одной ноды в пакетном режиме
   * Вызывается из NeuroNode при завершении генерации
   * 
   * @param nodeId - ID завершившей генерацию ноды
   */
  onBatchNodeComplete: (nodeId: string) => void;
}

// =============================================================================
// ПОЛНЫЙ ТИП STORE
// =============================================================================

/**
 * Полный тип Zustand store (состояние + экшены)
 */
export type CanvasStore = CanvasState & CanvasActions;

// =============================================================================
// ТИПЫ ДЛЯ API
// =============================================================================

/**
 * Тело запроса к /api/chat
 */
export interface ChatRequest {
  /** Сообщения в формате OpenAI */
  messages: ChatMessage[];

  /** Контекст от родительских нод (опционально) */
  context?: string;

  // =============================================================================
  // ВЛОЖЕНИЯ (ATTACHMENTS)
  // =============================================================================
  //
  // ВАЖНО:
  // - Эти поля используются клиентом при запросе на /api/chat.
  // - Сервер, получив canvasId + attachments, сам читает файлы с диска:
  //   - text → добавляет как system-context
  //   - image → добавляет как multimodal parts в user message

  /** ID активного холста (нужен, чтобы сервер нашёл файлы вложений на диске). */
  canvasId?: string;

  /** Вложения текущей карточки (метаданные + attachmentId). */
  attachments?: NodeAttachment[];

  /** API ключ для авторизации */
  apiKey?: string;

  /** Название модели (например "openai/gpt-4o") */
  model?: string;
}

/**
 * Формат сообщения для API
 */
export interface ChatMessage {
  /** Роль отправителя */
  role: 'system' | 'user' | 'assistant';

  /** Содержимое сообщения */
  content: string;
}

/**
 * Конфигурация внешнего LLM API
 */
export interface LLMApiConfig {
  /** API ключ для авторизации */
  apiKey: string;

  /** Название модели (например "openai/gpt-4o") */
  model: string;

  /** Температура генерации (0-2) */
  temperature?: number;

  /** Максимальное количество токенов */
  maxTokens?: number;
}

// =============================================================================
// ТИПЫ ДЛЯ API СУММАРИЗАЦИИ
// =============================================================================

/**
 * Тело запроса к /api/summarize
 */
export interface SummarizeRequest {
  /** Текст для суммаризации */
  text: string;

  /** API ключ для авторизации */
  apiKey?: string;

  /** Название модели (например "openai/gpt-4o") */
  model?: string;
}

/**
 * Ответ от /api/summarize
 */
export interface SummarizeResponse {
  /** Краткое резюме текста */
  summary: string;
}

// =============================================================================
// ТИПЫ ДЛЯ СИСТЕМЫ КОНТЕКСТА
// =============================================================================

/**
 * Тип контекста для блока предка
 * 
 * Определяется автоматически:
 * - full: полный response (для прямых родителей без цитаты)
 * - quote: выделенная цитата (если у карточки есть поле quote)
 * - summary: краткое резюме (для дедушек и далее)
 * - neuro-search: контекст из семантического поиска (виртуальные родители)
 */
export type ContextType = 'full' | 'quote' | 'summary' | 'neuro-search';

/**
 * Блок контекста от одного предка
 * 
 * Представляет один элемент в цепочке контекста.
 * Используется для отображения в модальном окне и для построения
 * контекста при генерации ответа LLM.
 * 
 * ВАЖНО: Блоки контекста формируются динамически в момент:
 * - Генерации ответа LLM (buildParentContext)
 * - Открытия модального окна просмотра контекста
 * 
 * Хранение: только ID родителей (parentId/parentIds) и тип определяется автоматически.
 */
export interface ContextBlock {
  /** ID ноды-источника контекста */
  nodeId: string;

  /** Вопрос (prompt) из ноды-источника */
  prompt: string;

  /** Тип контекста (full/quote/summary) */
  type: ContextType;

  /** Содержимое контекста (response, quote или summary) */
  content: string;

  /** 
   * Уровень в иерархии:
   * - 0 = прямой родитель
   * - 1 = дедушка
   * - 2 = прадедушка
   * - и т.д.
   */
  level: number;

  /** Локализованное название уровня (например, "Родительская карточка", "Дедушка") */
  levelName: string;
}

/**
 * Информация о связи с контекстом
 * 
 * Расширяет базовую информацию о связи (edge) данными о типе контекста.
 * Тип определяется автоматически на основе данных карточки.
 */
export interface ContextConnection {
  /** ID родительской ноды (source) */
  sourceNodeId: string;

  /** ID дочерней ноды (target) */
  targetNodeId: string;

  /** 
   * Тип контекста для этой связи
   * Определяется автоматически:
   * - quote: если у target есть quote от source
   * - summary: если source не прямой родитель
   * - full: для прямых родителей без цитаты
   */
  contextType: ContextType;
}

