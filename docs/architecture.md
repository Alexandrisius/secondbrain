# Архитектура приложения NeuroCanvas

## Обзор
**NeuroCanvas** — это AI-native приложение для мышления и работы со знаниями, реализованное как бесконечный холст (infinite canvas). Ключевая особенность — иерархическая генерация контента, где выходные данные одной карточки становятся контекстом для дочерних карточек.

Приложение построено на **Electron** + **Next.js** и использует локальные модели (или API) для генерации текста и эмбеддингов.

---

## Технологический стек

### Core
*   **Framework**: Next.js 14 (App Router)
*   **Platform**: Electron (с поддержкой кросс-платформенной сборки через `electron-builder`)
*   **Language**: TypeScript 5
*   **Canvas Engine**: @xyflow/react (React Flow)
*   **State Management**: Zustand + Immer + Zundo (Undo/Redo)
*   **Storage**:
    *   JSON (основной файл холста)
    *   Dexie (IndexedDB) - для векторного индекса и метаданных
    *   Файловая система - для хранения вложений (attachments)

### UI/UX
*   **Styling**: Tailwind CSS
*   **Components**: Shadcn/UI (@radix-ui), Lucide React
*   **Animations**: Framer Motion
*   **Markdown**: react-markdown, remark-gfm

### AI & Search
*   **Search Engine**: Hybrid Search (Vector + Keyword)
*   **Embeddings**: Local ONNX Runtime (предположительно, или через API)

---

## Архитектура данных (Data Model)

Основной единицей данных является **NeuroNode** (карточка). Типизация описана в `src/types/canvas.ts`.

### NeuroNode
Карточка содержит не только контент, но и метаданные для управления контекстом:

*   **Content**:
    *   `prompt`: Запрос пользователя.
    *   `response`: Ответ LLM.
    *   `summary`: Сжатая версия ответа (генерируется автоматически) для передачи дальним потомкам.
    *   `note`: (для NoteNode) Markdown заметка.
*   **State**:
    *   `isStale`: Флаг устаревания. Если родитель изменился, дети помечаются как `stale`.
    *   `lastContextHash`: Хэш контекста, при котором был сгенерирован текущий ответ. Используется для "умного" снятия флага `isStale`.
    *   `mode`: Режим отображения (`input` | `result`).
*   **Context Control**:
    *   `excludedContextNodeIds`: Список предков, исключенных из контекста вручную.
    *   `excludedAttachmentIds`: Список вложений, исключенных из контекста.

### Context Strategy (Стратегия контекста)
Уникальная особенность архитектуры — **сжатие контекста по глубине**:

1.  **Прямые родители (Direct Parents)**:
    *   Передается **полный `response`**.
    *   Вложения передаются в виде summary или short excerpts (зависит от настроек).
2.  **Дальние предки (Ancestors - Grandparents+)**:
    *   Передается **`summary`** (сжатая суть).
    *   Это позволяет создавать глубокие цепочки рассуждений, не переполняя контекстное окно LLM.
3.  **Вложения (Attachments)**:
    *   Хранятся в глобальной библиотеке (`data/library`).
    *   В ноде хранятся только метаданные (`attachmentId`, `mime`, `size`).
    *   Для LLM контент вложений подмешивается динамически (inline или chunked).

---

## Управление состоянием (State Management)

Состояние управляется библиотекой **Zustand** в файле `src/store/useCanvasStore.ts`.
*На данный момент стор представляет собой монолитную структуру, но планируется (или идет) рефакторинг на слайсы.*

### Ключевые механизмы Store

1.  **Persistence (Сохранение)**
    *   Данные автоматически сохраняются в JSON файл.
    *   Используется `debounce` (1 сек) для оптимизации записи.
    *   Реализована защита от потери данных при ошибках записи.

2.  **Undo/Redo (История)**
    *   Используется middleware `zundo`.
    *   **Smart Debounce**: Быстрые изменения (например, ввод текста) группируются в один шаг истории (500ms).
    *   **Ignored Fields**: UI-состояния (`isGenerating`, `selected`, `dragging`) исключены из истории, чтобы не засорять стек отмены.
    *   **Index Sync**: При Undo/Redo происходит автоматическая синхронизация поисковых индексов (удаление/добавление эмбеддингов).

3.  **Context Hashing & Stale Logic**
    *   Система отслеживает актуальность данных через хэширование.
    *   `computeContextHash(nodeId)`: Собирает весь влияющий контекст (промпты родителей, ответы, включенные вложения) -> нормализует -> хэширует (djb2).
    *   Если вычисленный хэш не совпадает с `lastContextHash`, карточка помечается (или остается) `stale`.
    *   Это позволяет избежать ложных срабатываний (например, если изменить пробел в родители, нормализация это скроет).

4.  **Batch Regeneration (Пакетная регенерация)**
    *   Позволяет обновить всю ветку изменений одной кнопкой.
    *   Использует **Топологическую сортировку**:
        1.  Строится граф зависимостей `stale` нод.
        2.  Ноды разбиваются на уровни (слои).
        3.  Генерация идет уровень за уровнем (параллельно внутри уровня).

---

## Компонентная структура (Components)

Все канвас-компоненты находятся в `src/components/canvas`.

### `CanvasContent.tsx`
Главная обертка. Инициализирует `ReactFlow`, обрабатывает хоткеи, Drag&Drop файлов и зум.

### `NeuroNode.tsx`
Основной компонент AI-карточки. Разделен на под-компоненты (в `neuro-node/`):
*   `QuestionSection`: Ввод промпта, управление вложениями.
*   `AnswerSection`: Вывод Markdown ответа, тулбар действий (Regenerate, Copy, etc).
*   `AnswerToolbar`: Кнопки управления ответом.

### `ContextViewerModal.tsx`
Сложный компонент для визуализации того, что *на самом деле* видит LLM.
*   Показывает полный собранный промпт.
*   Цветовое кодирование источников (прямой родитель vs предок).
*   Позволяет исключать отдельные блоки из контекста.

### `NoteNode.tsx`
Упрощенная карточка для ручных заметок. Не делает запросов к LLM, но может быть родителем для NeuroNode (ее текст попадет в контекст).

---

## Потоки данных (Data Flow)

### 1. Генерация ответа
1.  Пользователь вводит Prompt -> `updateNodeData`.
2.  Нажимает "Generate".
3.  `NeuroNode` собирает контекст -> отправляет в системный API.
4.  Ответ стримится обратно в `response`.
5.  По завершении:
    *   Генерируется `summary` (фоновая задача).
    *   Вычисляется и сохраняется `lastContextHash`.
    *   Вызывается `markChildrenStale` -> дети становятся оранжевыми.

### 2. NeuroSearch (Виртуальные связи)
1.  Пользователь активирует поиск в карточке.
2.  Система ищет релевантные ноды в векторном индексе.
3.  Найденные ID записываются в `neuroSearchNodeIds`.
4.  Эти ноды становятся "виртуальными родителями": их контент подмешивается в контекст, но физической связи (Edge) на холсте нет.

---
*Документация актуальна для версии 1.1.0*
